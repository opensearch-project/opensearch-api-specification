syntax = "proto3";

option java_multiple_files = true;
option java_package = "opensearch.protos";
option java_outer_classname = "CommonProto";
option go_package = "opensearchpb";

import "google/protobuf/wrappers.proto";
import "google/protobuf/struct.proto";


message WaitForActiveShards {

  enum WaitForActiveShardOptions {
    
    WAIT_FOR_ACTIVE_SHARD_OPTIONS_INVALID = 0;
    WAIT_FOR_ACTIVE_SHARD_OPTIONS_ALL = 1;
    WAIT_FOR_ACTIVE_SHARD_OPTIONS_INDEX_SETTING = 2;
  }

  oneof wait_for_active_shards {
    .google.protobuf.Int32Value int32_value = 1;
    WaitForActiveShardOptions wait_for_active_shard_options = 2;
  }

}

message Script {
  oneof script {
    // Defines an inline script to execute as part of a query.
    InlineScript inline_script = 1;
    // References a stored script by its ID for use in a query.
    StoredScriptId stored_script_id = 2;
  }
}

message InlineScript {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;

  // [optional]
  // The script's language. Default is painless.
  ScriptLanguage lang = 2;

  map<string, .google.protobuf.StringValue> options = 3;

  // [required]
  // The script source.
  .google.protobuf.StringValue source = 4;
}

message ScriptLanguage {
  enum BuiltinScriptLanguage {
    
    BUILTIN_SCRIPT_LANGUAGE_INVALID = 0;
    BUILTIN_SCRIPT_LANGUAGE_EXPRESSION = 1;
    BUILTIN_SCRIPT_LANGUAGE_JAVA = 2;
    BUILTIN_SCRIPT_LANGUAGE_MUSTACHE = 3;
    BUILTIN_SCRIPT_LANGUAGE_PAINLESS = 4;
  }
  BuiltinScriptLanguage builtin_script_language = 1;
  .google.protobuf.StringValue string_value = 2;
}

message StoredScriptId {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;
  // [required]
  // The ID of a stored script previously created using the Create Stored Script API.
  .google.protobuf.StringValue id = 2;
}

message ObjectMap {
  map<string, Value> fields = 1;

  message Value {
    // The kind of value.
    oneof value {
      // Represents a null value.
      NullValue null_value = 1;
      // Represents a .google.protobuf.DoubleValue value.
      GeneralNumber general_number = 2;
      // Represents a .google.protobuf.StringValue value.
      .google.protobuf.StringValue string_value = 3;
      // Represents a boolean value.
      .google.protobuf.BoolValue bool_value = 4;
      // Represents a structured value.
      ObjectMap object_map = 5;
      // Represents a repeated `Value`.
      ListValue list_value = 6;
    }

  }

  // `ListValue` is a wrapper around a repeated field of values.
  // The JSON representation for `ListValue` is JSON array.
  message ListValue {
    // Repeated field of dynamically typed values.
    repeated ValueWithoutWrappers value_without_wrappers = 1;
  }

  message ValueWithoutWrappers {
    oneof value_without_wrappers {
      NullValue null_value = 1;
      int32 int32 = 2;
      int64 int64 = 3;
      float float = 4;
      double double = 5;
      string string = 6;
      bool bool = 7;
      ObjectMap object_map = 8;
      ListValue list_value = 9;
    }
  }
}

enum NullValue {
  
  NULL_VALUE_INVALID = 0;
  NULL_VALUE_NULL = 1;
}

message GeoLocation {

  oneof geo_location {
    LatLonGeoLocation lat_lon_geo_location = 1;
    GeoHashLocation geo_hash_location = 2;
    NumberArray number_array = 3;
  }

}

message NumberArray {

  repeated double number_array = 1;

}

message LatLonGeoLocation {
  // Latitude
  .google.protobuf.DoubleValue lat = 1;

  // Longitude
  .google.protobuf.DoubleValue lon = 2;

}

message GeoHashLocation {

  .google.protobuf.StringValue geohash = 1;

}

message GeneralNumber {
  oneof value{
    .google.protobuf.Int32Value int32_value = 1;
    .google.protobuf.Int64Value int64_value = 2;
    .google.protobuf.FloatValue float_value = 3;
    .google.protobuf.DoubleValue double_value = 4;
  }
}

message SourceConfigParam {

  oneof source_config_param {
    // `true` or `false` to return the `_source` field or not
    .google.protobuf.BoolValue bool_value = 1;
    // list of fields to be retrieved from `_source`
    StringArray string_array = 2;
  }

}

message StringArray{
  repeated string string_array = 1;
}

message StringOrStringArray {
  oneof string_or_string_array{
    .google.protobuf.StringValue string_value = 1;
    StringArray string_array = 2;
  }
}

message SourceConfig {

  oneof source_config{
    // [optional] if the source_config is bool value. true: The entire document source is returned. false: The document source is not returned.
    .google.protobuf.BoolValue bool_value = 1;
    // [optional] Array of patterns containing source fields to return.
    StringArray string_array = 2;
    // [optional] source_filter type containing a list of source fields to include or exclude.
    SourceFilter source_filter = 3;
  }

}

message RuntimeField {

  // For type `lookup`
  repeated RuntimeFieldFetchFields fetch_fields = 1;

  // A custom format for `date` type runtime fields.
  .google.protobuf.StringValue format = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue input_field = 3;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue target_field = 4;

  .google.protobuf.StringValue target_index = 5;

  Script script = 6;

  enum RuntimeFieldType {
    
    RUNTIME_FIELD_TYPE_INVALID = 0;
    RUNTIME_FIELD_TYPE_BOOLEAN = 1;
    RUNTIME_FIELD_TYPE_DATE = 2;
    RUNTIME_FIELD_TYPE_DOUBLE = 3;
    RUNTIME_FIELD_TYPE_GEO_POINT = 4;
    RUNTIME_FIELD_TYPE_IP = 5;
    RUNTIME_FIELD_TYPE_KEYWORD = 6;
    RUNTIME_FIELD_TYPE_LONG = 7;
    RUNTIME_FIELD_TYPE_LOOKUP = 8;
  }

  RuntimeFieldType type = 7;

}

message RuntimeFieldFetchFields {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue field = 1;

  .google.protobuf.StringValue format = 2;

}

message SourceFilter {
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to exclude from the response.
  repeated string excludes = 1;
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to return.
  repeated string includes = 2;
}

message ErrorCause {

  // The type of error
  .google.protobuf.StringValue type = 1;

  // A human-readable explanation of the error, in english
  .google.protobuf.StringValue reason = 2;

  // The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.
  .google.protobuf.StringValue stack_trace = 3;

  ErrorCause caused_by = 4;

  repeated ErrorCause root_cause = 5;

  repeated ErrorCause suppressed = 6;

  .google.protobuf.StringValue index = 7;

  .google.protobuf.StringValue shard = 8;

  .google.protobuf.StringValue index_uuid = 9;

  .google.protobuf.Struct additional_details = 10;

}

message ShardStatistics {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  .google.protobuf.Int32Value failed = 1;

  // [required] Number of shards that executed the request successfully.
  .google.protobuf.Int32Value successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  .google.protobuf.Int32Value total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

  // [optional] Number of shards that skipped the request because a lightweight check helped realize that no documents could possibly match on this shard. This typically happens when a search request includes a range filter and the shard only has values that fall outside of that range.
  .google.protobuf.Int32Value skipped = 5;

}

message ShardFailure {

  // [optional] Name of the index in which the shard failure occurred.
  .google.protobuf.StringValue index = 1;

  // [optional] ID of the node where the shard is located.
  .google.protobuf.StringValue node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  .google.protobuf.Int32Value shard = 4;

  // [optional] Error status.
  .google.protobuf.StringValue status = 5;

}

message QueryContainer {

  BoolQuery bool = 1;

  BoostingQuery boosting = 2;

  ConstantScoreQuery constant_score = 3;

  DisMaxQuery dis_max = 4;

  FunctionScoreQuery function_score = 5;

  // [optional]
  // Use the exists query to search for documents that contain a specific field.
  ExistsQuery exists = 6;

  // [optional]
  // Fuzzy query is to searches for documents containing terms that are similar to the search term within the maximum allowed Damerau–Levenshtein distance. The Damerau–Levenshtein distance measures the number of one-character changes needed to change one term to another term.
  // only 1 entry can be provided in the map
  map<string, FuzzyQuery> fuzzy = 7;

  IdsQuery ids = 8;

  // [optional]
  // Prefix query is to search for terms that begin with a specific prefix.
  // only 1 entry can be provided in the map
  map<string, PrefixQuery> prefix = 9;

  // Returns documents that contain terms within a provided range.
  // only 1 entry can be provided in the map
  map<string, RangeQuery> range = 10;

  // Returns documents that contain terms matching a regular expression.
  // only 1 entry can be provided in the map
  map<string, RegexpQuery> regexp = 11;

  // [optional]
  // Term query is to search for an exact term in a field. The term query does not analyze the search term. The term query only searches for the exact term you provide.
  // only 1 entry can be provided in the map
  map<string, TermQueryFieldValue> term = 12;

  // [optional]
  // Terms query field is to search for documents containing one or more terms in a specific field. Use the terms query to search for multiple terms in the same field.
  TermsQueryField terms = 13;

  // [optional]
  // terms set query is to search for documents that match a minimum number of exact terms in a specified field. A terms_set query is similar to a terms query, except that you can specify the minimum number of matching terms that are required in order to return a document. You can specify this number either in a field in the index or with a script.
  // only 1 entry can be provided in the map
  map<string, TermsSetQuery> terms_set = 14;

  // Returns documents that contain terms matching a wildcard pattern.
  // only 1 entry can be provided in the map
  map<string, WildcardQuery> wildcard = 15;

  // [optional]
  // Use the match query for full-text search on a specific document field. If you run a match query on a text field, the match query analyzes the provided search string and returns documents that match any of the string's terms. If you run a match query on an exact-value field, it returns documents that match the exact value. The preferred way to search exact-value fields is to use a filter because, unlike a query, a filter is cached.
  // only 1 entry can be provided in the map
  map<string, MatchQueryTypeless> match = 16;

  // [optional]
  // The match_bool_prefix query analyzes the provided search string and creates a Boolean query from the string's terms. It uses every term except the last term as a whole word for matching. The last term is used as a prefix. The match_bool_prefix query returns documents that contain either the whole-word terms or terms that start with the prefix term, in any order.
  // only 1 entry can be provided in the map
  map<string, MatchBoolPrefixQuery> match_bool_prefix = 17;

  // [optional]
  // Use the match_phrase query to match documents that contain an exact phrase in a specified order. You can add flexibility to phrase matching by providing the slop parameter.
  // only 1 entry can be provided in the map
  map<string, MatchPhraseQuery> match_phrase = 18;

  // [optional]
  // Use the match_phrase_prefix query to specify a phrase to match in order. The documents that contain the phrase you specify will be returned. The last partial term in the phrase is interpreted as a prefix, so any documents that contain phrases that begin with the phrase and prefix of the last term will be returned.
  // only 1 entry can be provided in the map
  map<string, MatchPhrasePrefixQuery> match_phrase_prefix = 19;

  MultiMatchQuery multi_match = 20;

  QueryStringQuery query_string = 21;

  SimpleQueryStringQuery simple_query_string = 22;

  // Returns documents based on the order and proximity of matching terms.
  // only 1 entry can be provided in the map
  map<string, IntervalsQuery> intervals = 23;

  // [optional]
  // Knn query is to search for the k-nearest neighbors to a query point across an index of vectors. To determine the neighbors, you can specify the space (the distance function) you want to use to measure the distance between points.
  // only 1 entry can be provided in the map
  map<string, KnnField> knn = 24;

  // [optional]
  // The match all query returns all documents. This query can be useful in testing large document sets if you need to return the entire set.
  MatchAllQuery match_all = 25;

  MatchNoneQuery match_none = 26;

  ScriptScoreQuery script_score = 27;

  NestedQuery nested = 28;

}

message NestedQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  .google.protobuf.BoolValue ignore_unmapped = 3;

  InnerHits inner_hits = 4;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  .google.protobuf.StringValue path = 5;

  QueryContainer query = 6;

  enum ChildScoreMode {
    
    CHILD_SCORE_MODE_INVALID = 0;
    CHILD_SCORE_MODE_AVG = 1;
    CHILD_SCORE_MODE_MAX = 2;
    CHILD_SCORE_MODE_MIN = 3;
    CHILD_SCORE_MODE_NONE = 4;
    CHILD_SCORE_MODE_SUM = 5;
  }
  ChildScoreMode score_mode = 7;

}

message InnerHits {

  // [optional] The name to be used for the particular inner hit definition in the response. Useful when multiple inner hits have been defined in a single search request.
  .google.protobuf.StringValue name = 1;

  // [optional] The maximum number of hits to return per `inner_hits`.
  .google.protobuf.Int32Value size = 2;

  // [optional] Inner hit starting document offset.
  .google.protobuf.Int32Value from = 3;

  // [optional] The collapse parameter groups search results by a particular field value. This returns only the top document within each group, which helps reduce redundancy by eliminating duplicates.
  FieldCollapse collapse = 4;

  // [optional] The fields that OpenSearch should return using their docvalue forms. Specify a format to return results in a certain format, such as date and time.
  repeated FieldAndFormat docvalue_fields = 5;

  // [optional] Whether to return details about how OpenSearch computed the document's score. Default is false.
  .google.protobuf.BoolValue explain = 6;

  // [optional] Highlighting emphasizes the search term(s) in the results so you can emphasize the query matches.
  Highlight highlight = 7;

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  .google.protobuf.BoolValue ignore_unmapped = 8;

  // [optional] The script_fields parameter allows you to include custom fields whose values are computed using scripts in your search results. This can be useful for calculating values dynamically based on the document data. You can also retrieve derived fields by using a similar approach.
  map<string, ScriptField> script_fields = 9;

  // [optional] Whether to return sequence number and primary term of the last operation of each document hit.
  .google.protobuf.BoolValue seq_no_primary_term = 10;

  // [optional] Retrieve selected fields from a search
  repeated string fields = 11;

  // [optional] How the inner hits should be sorted per inner_hits. By default the hits are sorted by the score.
  repeated SortCombinations sort = 12;

  // [optional] Select what fields of the source are returned
  SourceConfig source = 13 [json_name = "_source"];

  // [optional] A list of stored fields to return as part of a hit. If no fields are specified, no stored fields are included in the response. If this option is specified, the _source parameter defaults to false. You can pass _source: true to return both source fields and stored fields in the search response.
  repeated string stored_fields = 14;

  // [optional] Whether to return document scores. Default is false.
  .google.protobuf.BoolValue track_scores = 15;

  // [optional] Whether to include the document version as a match.
  .google.protobuf.BoolValue version = 16;

}

message ScriptField {
  Script script = 1;
  .google.protobuf.BoolValue ignore_failure = 2;
}

message Highlight {

  enum HighlighterType {
    
    HIGHLIGHTER_TYPE_INVALID = 0;
    // The fvh highlighter uses the Lucene Fast Vector highlighter. This highlighter can be used on fields with term_vector set to with_positions_offsets in the mapping.
    HIGHLIGHTER_TYPE_FVH = 1;
    // The plain highlighter uses the standard Lucene highlighter. It attempts to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.
    HIGHLIGHTER_TYPE_PLAIN = 2;
    // The unified highlighter uses the Lucene Unified Highlighter. This highlighter breaks the text into sentences and uses the BM25 algorithm to score individual sentences as if they were documents in the corpus. It also supports accurate phrase and multi-term (fuzzy, prefix, regex) highlighting. The unified highlighter can combine matches from multiple fields into one result (see matched_fields). This is the default highlighter.
    HIGHLIGHTER_TYPE_UNIFIED = 3;
  }

  // [optional] Specifies the highlighter to use. Default is unified.
  HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  .google.protobuf.StringValue boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  .google.protobuf.Int32Value boundary_max_scan = 3;

  enum BoundaryScanner {
    
    BOUNDARY_SCANNER_INVALID = 0;
    // Split highlighted fragments at any character listed in boundary_chars. Valid only for the fvh highlighter.
    BOUNDARY_SCANNER_CHARS = 1;
    // Split highlighted fragments at sentence boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_SENTENCE = 2;
    // Split highlighted fragments at word boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_WORD = 3;
  }

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  .google.protobuf.StringValue boundary_scanner_locale = 5;

  // [x-deprecated]
  .google.protobuf.BoolValue force_source = 6;

  enum HighlighterFragmenter {
    
    HIGHLIGHTER_FRAGMENTER_INVALID = 0;
    // Splits text into fragments of the same size.
    HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
    // Splits text into fragments of the same size but tries not to split text between highlighted terms.
    HIGHLIGHTER_FRAGMENTER_SPAN = 2;
  }

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  .google.protobuf.Int32Value fragment_size = 8;

  .google.protobuf.BoolValue highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  QueryContainer highlight_query = 10;

  .google.protobuf.Int32Value max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  .google.protobuf.Int32Value max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  .google.protobuf.Int32Value no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  .google.protobuf.Int32Value number_of_fragments = 14;

  ObjectMap options = 15;

  enum HighlighterOrder {
    
    HIGHLIGHTER_ORDER_INVALID = 0;
    // Sort fragments by relevance.
    HIGHLIGHTER_ORDER_SCORE = 1;
  }

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  .google.protobuf.Int32Value phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  .google.protobuf.BoolValue require_field_match = 20;

  enum HighlighterTagsSchema {
    
    HIGHLIGHTER_TAGS_SCHEMA_INVALID = 0;
    // Defines the following pre_tags and defines post_tags as </em>.
    HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
  }

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  HighlighterTagsSchema tags_schema = 21;

  enum HighlighterEncoder {
    
    HIGHLIGHTER_ENCODER_INVALID = 0;
    // No encoding
    HIGHLIGHTER_ENCODER_DEFAULT = 1;
    // First escape the HTML text and then insert the highlighting tags
    HIGHLIGHTER_ENCODER_HTML = 2;
  }

  // [optional] Specifies whether the highlighted fragment should be HTML encoded before it is returned.
  HighlighterEncoder encoder = 22;

  // [required] Specifies the fields to search for text to be highlighted. Supports wildcard expressions. If you use wildcards, only text and keyword fields are highlighted. For example, you can set fields to my_field* to include all text and keyword fields that start with the prefix my_field.
  map<string, HighlightField> fields = 23;

}

message HighlightField {

  enum HighlighterType {
    
    HIGHLIGHTER_TYPE_INVALID = 0;
    // The fvh highlighter uses the Lucene Fast Vector highlighter. This highlighter can be used on fields with term_vector set to with_positions_offsets in the mapping.
    HIGHLIGHTER_TYPE_FVH = 1;
    // The plain highlighter uses the standard Lucene highlighter. It attempts to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.
    HIGHLIGHTER_TYPE_PLAIN = 2;
    // The unified highlighter uses the Lucene Unified Highlighter. This highlighter breaks the text into sentences and uses the BM25 algorithm to score individual sentences as if they were documents in the corpus. It also supports accurate phrase and multi-term (fuzzy, prefix, regex) highlighting. The unified highlighter can combine matches from multiple fields into one result (see matched_fields). This is the default highlighter.
    HIGHLIGHTER_TYPE_UNIFIED = 3;
  }

  // [optional] Specifies the highlighter to use. Default is unified.
  HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  .google.protobuf.StringValue boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  .google.protobuf.Int32Value boundary_max_scan = 3;

  enum BoundaryScanner {
    
    BOUNDARY_SCANNER_INVALID = 0;
    // Split highlighted fragments at any character listed in boundary_chars. Valid only for the fvh highlighter.
    BOUNDARY_SCANNER_CHARS = 1;
    // Split highlighted fragments at sentence boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_SENTENCE = 2;
    // Split highlighted fragments at word boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_WORD = 3;
  }

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  .google.protobuf.StringValue boundary_scanner_locale = 5;

  // [x-deprecated]
  .google.protobuf.BoolValue force_source = 6;

  enum HighlighterFragmenter {
    
    HIGHLIGHTER_FRAGMENTER_INVALID = 0;
    // Splits text into fragments of the same size.
    HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
    // Splits text into fragments of the same size but tries not to split text between highlighted terms.
    HIGHLIGHTER_FRAGMENTER_SPAN = 2;
  }

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  .google.protobuf.Int32Value fragment_size = 8;

  .google.protobuf.BoolValue highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  QueryContainer highlight_query = 10;

  .google.protobuf.Int32Value max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  .google.protobuf.Int32Value max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  .google.protobuf.Int32Value no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  .google.protobuf.Int32Value number_of_fragments = 14;

  ObjectMap options = 15;

  enum HighlighterOrder {
    
    HIGHLIGHTER_ORDER_INVALID = 0;
    // Sort fragments by relevance.
    HIGHLIGHTER_ORDER_SCORE = 1;
  }

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  .google.protobuf.Int32Value phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  .google.protobuf.BoolValue require_field_match = 20;

  enum HighlighterTagsSchema {
    
    HIGHLIGHTER_TAGS_SCHEMA_INVALID = 0;
    // Defines the following pre_tags and defines post_tags as </em>.
    HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
  }

  HighlighterTagsSchema tags_schema = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  .google.protobuf.Int32Value fragment_offset = 22;

  // [optional] Combines matches from different fields to highlight one field. The most common use case for this functionality is highlighting text that is analyzed in different ways and kept in multi-fields. All fields in the matched_fields list must have the term_vector field set to with_positions_offsets. The field in which the matches are combined is the only loaded field, so it is beneficial to set its store option to yes. Valid only for the fvh highlighter.
  repeated string matched_fields = 23;

  Analyzer analyzer = 24;

}

message SortCombinations {
  oneof sort_combinations{
    // [optional] Sort based on field name.
    .google.protobuf.StringValue string_value = 1;
    // [optional] Sort based on a map of fields with specified order directions.
    FieldWithOrderMap field_with_order_map = 2;
    // [optional] Sort using a combination of advanced sort options, such as score, document ID, geo-distance, or a custom script.
    SortOptions sort_options = 3;
  }
}

message FieldWithOrderMap {
  // [required] Map of fields and their corresponding sort order.
  map<string, ScoreSort> field_with_order_map = 1;
}

message SortOptions {
  oneof sort_options{
    // [optional] Sort by score.
    ScoreSort score = 1 [json_name = "_score"];
    // [optional] Sort by index order.
    ScoreSort doc = 2 [json_name = "_doc"];
    // [optional] Sort by _geo_distance
    GeoDistanceSort geo_distance = 3 [json_name = "_geo_distance"];
    // [optional] Sort based on custom scripts
    ScriptSort script = 4 [json_name = "_script"];
  }
}

message ScoreSort {
  // Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;
  enum SortOrder {
    
    SORT_ORDER_INVALID = 0;
    // Sort in ascending order.
    SORT_ORDER_ASC = 1;
    // Sort in descending order
    SORT_ORDER_DESC = 2;
  }
}

message GeoDistanceSort {

  // Specifies how to handle a field with several geopoints.
  SortMode mode = 1;
  enum SortMode {
    
    SORT_MODE_INVALID = 0;
    // Use the average of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_AVG = 1;
    // Pick the highest value.
    SORT_MODE_MAX = 2;
    // Use the median of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_MEDIAN = 3;
    // Pick the lowest value.
    SORT_MODE_MIN = 4;
    // Use the sum of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_SUM = 5;
  }

  // [optional] Specifies the method of computing the distance.
  GeoDistanceType distance_type = 2;

  enum GeoDistanceType {
    
    GEO_DISTANCE_TYPE_INVALID = 0;
    // Default
    GEO_DISTANCE_TYPE_ARC = 1;
    // Faster but less accurate for long distances or close to the poles.
    GEO_DISTANCE_TYPE_PLANE = 2;
  }

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  .google.protobuf.BoolValue ignore_unmapped = 3;

  // [optional] Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 4;

  enum SortOrder {
    
    SORT_ORDER_INVALID = 0;
    // Sort in ascending order.
    SORT_ORDER_ASC = 1;
    // Sort in descending order
    SORT_ORDER_DESC = 2;
  }

  // [optional] Specifies the units used to compute sort values. Default is meters (m).
  DistanceUnit unit = 5;

  enum DistanceUnit {
    
    DISTANCE_UNIT_INVALID = 0;
    DISTANCE_UNIT_CM = 1;
    DISTANCE_UNIT_FT = 2;
    DISTANCE_UNIT_IN = 3;
    DISTANCE_UNIT_KM = 4;
    DISTANCE_UNIT_M = 5;
    DISTANCE_UNIT_MI = 6;
    DISTANCE_UNIT_MM = 7;
    DISTANCE_UNIT_NMI = 8;
    DISTANCE_UNIT_YD = 9;
  }
}

message ScriptSort {

  // [optional] Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;
  enum SortOrder {
    
    SORT_ORDER_INVALID = 0;
    // Sort in ascending order.
    SORT_ORDER_ASC = 1;
    // Sort in descending order
    SORT_ORDER_DESC = 2;
  }

  // [optional] The script to execute for custom sorting.
  Script script = 2;

  // [optional] Specifies script sort type.
  ScriptSortType type = 3;
  enum ScriptSortType {
    
    SCRIPT_SORT_TYPE_INVALID = 0;
    SCRIPT_SORT_TYPE_NUMBER = 1;
    SCRIPT_SORT_TYPE_STRING = 2;
    SCRIPT_SORT_TYPE_VERSION = 3;
  }

  // [optional] Specifies what array value should be chosen for sorting the document.
  SortMode mode = 4;
  enum SortMode {
    
    SORT_MODE_INVALID = 0;
    // Use the average of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_AVG = 1;
    // Pick the highest value.
    SORT_MODE_MAX = 2;
    // Use the median of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_MEDIAN = 3;
    // Pick the lowest value.
    SORT_MODE_MIN = 4;
    // Use the sum of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_SUM = 5;
  }

  // Supports sorting by fields that are inside one or more nested objects.
  NestedSortValue nested = 5;

}

message NestedSortValue {

  // [optional] A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no filter is active.
  QueryContainer filter = 1;

  // [optional] The maximum number of children to consider per root document when picking the sort value. Defaults to unlimited.
  .google.protobuf.Int32Value max_children = 2;

  // [optional] Same as top-level nested but applies to another nested path within the current nested object.
  NestedSortValue nested = 3;

  // [required] Specifies the path to the field on which to sort.
  .google.protobuf.StringValue path = 4;

}

message FieldAndFormat {

  // [required] Wildcard pattern. The request returns doc values for field names matching this pattern.
  .google.protobuf.StringValue field = 1;

  // [optional] Format in which the values are returned.
  .google.protobuf.StringValue format = 2;

  // [optional] Retrieve unmapped fields in an object from _source
  .google.protobuf.BoolValue include_unmapped = 3;

}

message FieldCollapse {

  // [required] The document field by which you want to group or collapse the search results
  .google.protobuf.StringValue field = 1;

  // [optional] Expanding each group uses an additional query for each inner_hit request for every collapsed hit in the response.
  repeated InnerHits inner_hits = 2;

  // [optional] Use to control the maximum number of concurrent searches allowed in this phase.
  .google.protobuf.Int32Value max_concurrent_group_searches = 3;

  // [optional] Nested collapse within this collapse.
  FieldCollapse collapse = 4;

}

message ScriptScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Documents with a score lower than this floating point number are excluded from the search results.
  .google.protobuf.FloatValue min_score = 3;

  QueryContainer query = 4;

  Script script = 5;

}

message ExistsQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;
  // [optional]
  // Query name for query tagging.
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [required]
  // Name of the field you wish to search.
  .google.protobuf.StringValue field = 3;

}

message SimpleQueryStringQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Analyzer used to convert text in the query .google.protobuf.StringValue into tokens.
  .google.protobuf.StringValue analyzer = 3;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  .google.protobuf.BoolValue analyze_wildcard = 4;

  // If `true`, the parser creates a match_phrase query for each multi-position token.
  .google.protobuf.BoolValue auto_generate_synonyms_phrase_query = 5;

  Operator default_operator = 6;
  enum Operator {
    
    OPERATOR_INVALID = 0;
    OPERATOR_AND = 1;
    OPERATOR_OR = 2;
  }

  repeated string fields = 7;

  PipeSeparatedFlagsSimpleQueryStringFlag flags = 8;

  // Maximum number of terms to which the query expands for fuzzy matching.
  .google.protobuf.Int32Value fuzzy_max_expansions = 9;

  // Number of beginning characters left unchanged for fuzzy matching.
  .google.protobuf.Int32Value fuzzy_prefix_length = 10;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  .google.protobuf.BoolValue fuzzy_transpositions = 11;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  .google.protobuf.BoolValue lenient = 12;

  MinimumShouldMatch minimum_should_match = 13;
  // Query .google.protobuf.StringValue in the simple query .google.protobuf.StringValue syntax you wish to parse and use for search.
  .google.protobuf.StringValue query = 14;

  // Suffix appended to quoted text in the query string.
  .google.protobuf.StringValue quote_field_suffix = 15;

}

message WildcardQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Allows case insensitive matching of the pattern with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  .google.protobuf.BoolValue case_insensitive = 3;

  MultiTermQueryRewrite rewrite = 4;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.
  .google.protobuf.StringValue value = 5;

  // Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.
  .google.protobuf.StringValue wildcard = 6;

}

message PipeSeparatedFlagsSimpleQueryStringFlag {

  enum SimpleQueryStringFlag {
    
    SIMPLE_QUERY_STRING_FLAG_INVALID = 0;
    SIMPLE_QUERY_STRING_FLAG_ALL = 1;
    SIMPLE_QUERY_STRING_FLAG_AND = 2;
    SIMPLE_QUERY_STRING_FLAG_ESCAPE = 3;
    SIMPLE_QUERY_STRING_FLAG_FUZZY = 4;
    SIMPLE_QUERY_STRING_FLAG_NEAR = 5;
    SIMPLE_QUERY_STRING_FLAG_NONE = 6;
    SIMPLE_QUERY_STRING_FLAG_NOT = 7;
    SIMPLE_QUERY_STRING_FLAG_OR = 8;
    SIMPLE_QUERY_STRING_FLAG_PHRASE = 9;
    SIMPLE_QUERY_STRING_FLAG_PRECEDENCE = 10;
    SIMPLE_QUERY_STRING_FLAG_PREFIX = 11;
    SIMPLE_QUERY_STRING_FLAG_SLOP = 12;
    SIMPLE_QUERY_STRING_FLAG_WHITESPACE = 13;
  }

  oneof pipe_separated_flags_simple_query_string_flag{
    .google.protobuf.StringValue string_value = 1;
    SimpleQueryStringFlag simple_query_string_flag = 2;
  }

}

message KnnField {
  // [optional]
  // Query vector. Must have the same number of dimensions as the vector field you are searching against.
  repeated float vector = 1;

  // [optional]
  // The final number of nearest neighbors to return as top hits.
  .google.protobuf.Int32Value k = 2;

  // [optional]
  // The minimum similarity score for a neighbor to be considered a hit.
  .google.protobuf.FloatValue min_score = 3;

  // [optional]
  // The maximum physical distance in vector space for a neighbor to be considered a hit.
  .google.protobuf.FloatValue max_distance = 4;

  // [optional]
  // Filters for the kNN search query. The kNN search will return the top k documents that also match this filter. If filter is not provided, all documents are allowed to match.
  QueryContainer filter = 5;

  // [optional]
  // Boost value to apply to kNN scores
  .google.protobuf.FloatValue boost = 6;

  // [optional]
  // Method parameters are dependent on the combination of engine and method used to create the index.
  // Available method ef_search see https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#ef_search and nprobes "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#nprobes"
  map<string, .google.protobuf.Int32Value> method_parameters = 7;

  // [optional]
  // Available in version later than 2.17
  // To explicitly apply rescoring, provide the rescore parameter in a query on a quantized index and specify the oversample_factor "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#rescoring-quantized-results-using-full-precision"
  map<string, .google.protobuf.FloatValue> rescore = 8;

}

message MatchQueryTypeless {
  oneof match_query_typeless {
    // Standard match query for performing a full-text search, including options for fuzzy matching.
    MatchQuery match_query = 1;
    // Simplified match query syntax by combining the <field> and query parameters
    ObjectMap object_map = 2;
  }
}

message MatchQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  .google.protobuf.StringValue analyzer = 3;

  // [optional]
  // Specifies whether to create a match phrase query automatically for multi-term synonyms.
  // For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false).
  // Default is true.
  .google.protobuf.BoolValue auto_generate_synonyms_phrase_query = 4;

  // [x-deprecated]
  .google.protobuf.FloatValue cutoff_frequency = 5;

  // [optional]
  // The number of character edits (insertions, deletions, substitutions, or transpositions) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1. Valid values are non-negative integers or AUTO.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 6;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 7;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  .google.protobuf.BoolValue fuzzy_transpositions = 8;

  // [optional]
  // Setting lenient to true ignores data type mismatches between the query and the document field.
  // For example, a query string of "8.2" could match a field of type float.
  // Default is false.
  .google.protobuf.BoolValue lenient = 9;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  .google.protobuf.Int32Value max_expansions = 10;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 11;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match.
  // Default is OR.
  Operator operator = 12;
  enum Operator {
    
    OPERATOR_INVALID = 0;
    // All terms need to match. The string `to be` is interpreted as `to AND be`
    OPERATOR_AND = 1;
    // Only one term needs to match. The string `to be` is interpreted as `to OR be`
    OPERATOR_OR = 2;
  }

  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  .google.protobuf.Int32Value prefix_length = 13;

  message Query {
    oneof query{
      // if the query value is string type.
      .google.protobuf.StringValue string_value = 1;
      // if the query value is number type.
      GeneralNumber general_number = 2;
      // if the query value is boolean type.
      .google.protobuf.BoolValue bool_value = 3;
    }
  }

  // [required]
  // The query string to use for search.
  Query query = 14;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string.
  // For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 15;

  enum ZeroTermsQuery {
    
    ZERO_TERMS_QUERY_INVALID = 0;
    // zero_terms_query specifies whether to match all documents (all).
    ZERO_TERMS_QUERY_ALL = 1;
    // zero_terms_query specifies whether to match no documents (none)
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message BoolQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // The clause (query) must appear in matching documents. However, unlike `must`, the score of the query will be ignored.
  repeated QueryContainer filter = 3;

  MinimumShouldMatch minimum_should_match = 4;

  // The clause (query) must appear in matching documents and will contribute to the score.
  repeated QueryContainer must = 5;

  // The clause (query) must not appear in the matching documents. Because scoring is ignored, a score of `0` is returned for all documents.
  repeated QueryContainer must_not = 6;

  // The clause (query) should appear in the matching document.
  repeated QueryContainer should = 7;

}

message MinimumShouldMatch{
  oneof minimum_should_match{
    // if minimum_should_match is integer type. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    .google.protobuf.Int32Value int32_value = 1;
    // if minimum_should_match is string type like percentage or combinations. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    .google.protobuf.StringValue string_value = 2;
  }
}

message BoostingQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.
  .google.protobuf.FloatValue negative_boost = 3;

  QueryContainer negative = 4;

  QueryContainer positive = 5;

}

message ConstantScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  QueryContainer filter = 3;

}

message DisMaxQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // One or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, OpenSearch uses the highest relevance score.
  repeated QueryContainer queries = 3;

  // Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.
  .google.protobuf.FloatValue tie_breaker = 4;

}

message FunctionScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  FunctionBoostMode boost_mode = 3;

  enum FunctionBoostMode {
    
    FUNCTION_BOOST_MODE_INVALID = 0;
    FUNCTION_BOOST_MODE_AVG = 1;
    FUNCTION_BOOST_MODE_MAX = 2;
    FUNCTION_BOOST_MODE_MIN = 3;
    FUNCTION_BOOST_MODE_MULTIPLY = 4;
    FUNCTION_BOOST_MODE_REPLACE = 5;
    FUNCTION_BOOST_MODE_SUM = 6;
  }

  // One or more functions that compute a new score for each document returned by the query.
  repeated FunctionScoreContainer functions = 4;

  // Restricts the new score to not exceed the provided limit.
  .google.protobuf.FloatValue max_boost = 5;

  // Excludes documents that do not meet the provided score threshold.
  .google.protobuf.FloatValue min_score = 6;

  QueryContainer query = 7;

  FunctionScoreMode score_mode = 8;

  enum FunctionScoreMode {
    
    FUNCTION_SCORE_MODE_INVALID = 0;
    FUNCTION_SCORE_MODE_AVG = 1;
    FUNCTION_SCORE_MODE_FIRST = 2;
    FUNCTION_SCORE_MODE_MAX = 3;
    FUNCTION_SCORE_MODE_MIN = 4;
    FUNCTION_SCORE_MODE_MULTIPLY = 5;
    FUNCTION_SCORE_MODE_SUM = 6;
  }

}

message IntervalsAllOf {

  // An array of rules to combine. All rules must produce a match in a document for the overall source to match.
  repeated IntervalsContainer intervals = 1;

  // Maximum number of positions between the matching terms. Intervals produced by the rules further apart than this are not considered matches.
  .google.protobuf.Int32Value max_gaps = 2;

  // If `true`, intervals produced by the rules should appear in the order in which they are specified.
  .google.protobuf.BoolValue ordered = 3;

  IntervalsFilter filter = 4;

}

message IntervalsAnyOf {

  // An array of rules to match.
  repeated IntervalsContainer intervals = 1;

  IntervalsFilter filter = 2;

}

message IntervalsMatch {

  // Analyzer used to analyze terms in the query.
  .google.protobuf.StringValue analyzer = 1;

  // Maximum number of positions between the matching terms. Terms further apart than this are not considered matches.
  .google.protobuf.Int32Value max_gaps = 2;

  // If `true`, matching terms must appear in their specified order.
  .google.protobuf.BoolValue ordered = 3;

  // Text you wish to find in the provided field.
  .google.protobuf.StringValue query = 4;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue use_field = 5;

  IntervalsFilter filter = 6;

}

message IntervalsQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  oneof intervals_query {
    IntervalsAllOf all_of = 3;

    IntervalsAnyOf any_of = 4;

    IntervalsFuzzy fuzzy = 5;

    IntervalsMatch match = 6;

    IntervalsPrefix prefix = 7;

    IntervalsWildcard wildcard = 8;
  }

}

message FunctionScoreContainer {
  QueryContainer filter = 1;

  .google.protobuf.FloatValue weight = 2;

  //TODO: add decay function
  oneof function_score_container {

    //   Decay function not supported
    //    DecayFunction exp = 3;
    //
    //    DecayFunction gauss = 4;
    //
    //    DecayFunction linear = 5;

    FieldValueFactorScoreFunction field_value_factor = 6;

    RandomScoreFunction random_score = 7;

    ScriptScoreFunction script_score = 8;
  }

}

message ScriptScoreFunction {

  Script script = 1;

}

message IntervalsFilter {
  oneof intervals_filter {
    IntervalsContainer after = 1;

    IntervalsContainer before = 2;

    IntervalsContainer contained_by = 3;

    IntervalsContainer containing = 4;

    IntervalsContainer not_contained_by = 5;

    IntervalsContainer not_containing = 6;

    IntervalsContainer not_overlapping = 7;

    IntervalsContainer overlapping = 8;

    Script script = 9;
  }

}

message IntervalsContainer {

  oneof intervals_container {
    IntervalsAllOf all_of = 1;

    IntervalsAnyOf any_of = 2;

    IntervalsFuzzy fuzzy = 3;

    IntervalsMatch match = 4;

    IntervalsPrefix prefix = 5;

    IntervalsWildcard wildcard = 6;
  }

}

message PrefixQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 3;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [required]
  // The term to search for in the field specified in <field>.
  .google.protobuf.StringValue value = 4;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  .google.protobuf.BoolValue case_insensitive = 5;

}

message TermsLookupFieldStringArrayMap {
  oneof terms_lookup_field_string_array_map {
    // terms_lookup_field terms you wish to find in the provided field
    TermsLookupField terms_lookup_field = 1;
    // string_array terms value you wish to find in the provided field
    StringArray string_array = 2;
  }
}

message TermsQueryField {
  // [optional]
  // A floating-point value that specifies the weight of this field toward the relevance score. Values above 1.0 increase the field's relevance. Values between 0.0 and 1.0 decrease the field's relevance.
  // Default is 1.0.
  .google.protobuf.FloatValue boost = 1;

  // [required]
  map<string, TermsLookupFieldStringArrayMap> terms_lookup_field_string_array_map = 2;
}

message TermsLookupField {

  // [required]
  // The name of the index from which to fetch field values
  .google.protobuf.StringValue index = 1;

  // [required]
  // The document ID of the document from which to fetch field values.
  .google.protobuf.StringValue id = 2;

  // [required]
  // The name of the field from which to fetch field values. Specify nested fields using dot path notation
  .google.protobuf.StringValue path = 3;

  // [optional]
  // Custom routing value of the document from which to fetch term values. If a custom routing value was provided when the document was indexed, this parameter is required.
  repeated string routing = 4;
}

message TermsSetQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The name of the numeric field that specifies the number of matching terms required in order to return a document in the results.
  .google.protobuf.StringValue minimum_should_match_field = 3;

  // [optional]
  // A script that returns the number of matching terms required in order to return a document in the results.
  Script minimum_should_match_script = 4;

  // [required]
  // The array of terms to search for in the field specified in <field>. A document is returned in the results only if the required number of terms matches the document's field values exactly, with the correct spacing and capitalization.
  repeated string terms = 5;

}

message TermQueryFieldValue {
  oneof term_query_field_value{
    TermQuery term_query = 1;
    FieldValue field_value = 2;
  }
}

message TermQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [required]
  // Term you wish to find in the provided <field>. To return a document, the term must exactly match the field value, including whitespace and capitalization.
  FieldValue value = 3;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. When `false`, the case sensitivity of matching depends on the underlying field's mapping.
  .google.protobuf.BoolValue case_insensitive = 4;

}


message QueryStringQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  .google.protobuf.BoolValue allow_leading_wildcard = 3;

  // Analyzer used to convert text in the query .google.protobuf.StringValue into tokens.
  .google.protobuf.StringValue analyzer = 4;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  .google.protobuf.BoolValue analyze_wildcard = 5;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  .google.protobuf.BoolValue auto_generate_synonyms_phrase_query = 6;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue default_field = 7;

  Operator default_operator = 8;
  enum Operator {
    
    OPERATOR_INVALID = 0;
    OPERATOR_AND = 1;
    OPERATOR_OR = 2;
  }

  // If `true`, enable position increments in queries constructed from a `query_string` search.
  .google.protobuf.BoolValue enable_position_increments = 9;

  .google.protobuf.BoolValue escape = 10;

  repeated string fields = 11;

  Fuzziness fuzziness = 12;

  // Maximum number of terms to which the query expands for fuzzy matching.
  .google.protobuf.Int32Value fuzzy_max_expansions = 13;

  // Number of beginning characters left unchanged for fuzzy matching.
  .google.protobuf.Int32Value fuzzy_prefix_length = 14;

  MultiTermQueryRewrite fuzzy_rewrite = 15;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  .google.protobuf.BoolValue fuzzy_transpositions = 16;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  .google.protobuf.BoolValue lenient = 17;

  // Maximum number of automaton states required for the query.
  .google.protobuf.Int32Value max_determinized_states = 18;

  MinimumShouldMatch minimum_should_match = 19;

  // Maximum number of positions allowed between matching tokens for phrases.
  .google.protobuf.Int32Value phrase_slop = 20;

  // Query .google.protobuf.StringValue you wish to parse and use for search.
  .google.protobuf.StringValue query = 21;

  // Analyzer used to convert quoted text in the query .google.protobuf.StringValue into tokens. For quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.
  .google.protobuf.StringValue quote_analyzer = 22;

  // Suffix appended to quoted text in the query string. You can use this suffix to use a different analysis method for exact matches.
  .google.protobuf.StringValue quote_field_suffix = 23;

  MultiTermQueryRewrite rewrite = 24;

  // How to combine the queries generated from the individual search terms in the resulting `dis_max` query.
  .google.protobuf.FloatValue tie_breaker = 25;

  .google.protobuf.StringValue time_zone = 26;

  TextQueryType type = 27;
  enum TextQueryType {
    
    TEXT_QUERY_TYPE_INVALID = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

}

message RandomScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue field = 1;

  message Seed {
    oneof seed {
      .google.protobuf.Int32Value int32_value = 1;
      .google.protobuf.StringValue string_value = 2;
    }
  }
  Seed seed = 2;
}

// TODO: need to revisit RangeQuery def
message RangeQuery {
  oneof range_query{
    DateRangeQuery date_range_query = 1;
    NumberRangeQuery number_range_query = 2;
  }
}

message RegexpQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`. When `false`, case sensitivity of matching depends on the underlying field's mapping.
  .google.protobuf.BoolValue case_insensitive = 3;

  // Enables optional operators for the regular expression.
  .google.protobuf.StringValue flags = 4;

  // Maximum number of automaton states required for the query.
  .google.protobuf.Int32Value max_determinized_states = 5;

  MultiTermQueryRewrite rewrite = 6;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // Regular expression for terms you wish to find in the provided field.
  .google.protobuf.StringValue value = 7;

}

message DateRangeQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  RangeRelation relation = 3;
  enum RangeRelation {
    
    RANGE_RELATION_INVALID = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }

  .google.protobuf.StringValue gt = 4;

  .google.protobuf.StringValue gte = 5;

  .google.protobuf.StringValue lt = 6;

  .google.protobuf.StringValue lte = 7;

  message From {
    oneof from {
      .google.protobuf.StringValue string_value = 1;
      NullValue null_value = 2;
    }
  }

  From from = 8;

  message To {
    oneof to {
      .google.protobuf.StringValue string_value = 1;
      NullValue null_value = 2;
    }
  }
  To to = 9;

  .google.protobuf.StringValue format = 10;

  .google.protobuf.StringValue time_zone = 11;

}

message NumberRangeQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  RangeRelation relation = 3;
  enum RangeRelation {
    
    RANGE_RELATION_INVALID = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }


  // Greater than.
  GeneralNumber gt = 4;

  // Greater than or equal to.
  GeneralNumber gte = 5;

  // Less than.
  GeneralNumber lt = 6;

  // Less than or equal to.
  GeneralNumber lte = 7;

  message From {
    oneof from {
      .google.protobuf.StringValue string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  From from = 8;

  message To {
    oneof to {
      .google.protobuf.StringValue string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  To to = 9;
}

message FuzzyQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  .google.protobuf.Int32Value max_expansions = 3;

  // [optional]
  // The number of leading characters that are not considered in fuzziness. Default is 0.
  .google.protobuf.Int32Value prefix_length = 4;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 5;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }
  // [optional]
  // Specifies whether to allow transpositions of two adjacent characters (ab to ba) as edits. Default is true.
  .google.protobuf.BoolValue transpositions = 6;
  // [optional]
  // The number of character edits (insert, delete, substitute) needed to change one word to another when determining whether a term matched a value.
  Fuzziness fuzziness = 7;

  message Value {
    oneof value {
      .google.protobuf.StringValue string_value = 1;
      .google.protobuf.BoolValue bool_value = 2;
      GeneralNumber general_number = 3;
    }
  }

  // [required]
  // Term you wish to find in the provided <field>.
  Value value = 8;
}

message Fuzziness{

  oneof fuzziness{
    // AUTO: Generates an edit distance based on the length of the term. Low and high distance arguments may be optionally provided AUTO:[low],[high]. AUTO should generally be the preferred value for fuzziness.
    .google.protobuf.StringValue string_value = 1;
    // 0,1,2: The maximum allowed Levenshtein Edit Distance (or number of edits)
    .google.protobuf.Int32Value int32_value = 2;
  }

}

message FieldValue {
  oneof type{
    GeneralNumber general_number = 1;
    .google.protobuf.StringValue string_value = 2;
    ObjectMap object_map = 3;
    .google.protobuf.BoolValue bool_value = 4;
  }
}

message FieldValueResponse {
  oneof value{
    .google.protobuf.DoubleValue double_value = 1;
    .google.protobuf.StringValue string_value = 2;
    .google.protobuf.Struct object = 3;
    .google.protobuf.BoolValue bool_value = 4;
  }
}

message IdsQuery {

  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  repeated string values = 3;

}

message IntervalsFuzzy {

  // Analyzer used to normalize the term.
  .google.protobuf.StringValue analyzer = 1;

  Fuzziness fuzziness = 2;

  // Number of beginning characters left unchanged when creating expansions.
  .google.protobuf.Int32Value prefix_length = 3;

  // The term to match.
  .google.protobuf.StringValue term = 4;

  // Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).
  .google.protobuf.BoolValue transpositions = 5;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue use_field = 6;

}

message IntervalsPrefix {

  // Analyzer used to analyze the `prefix`.
  .google.protobuf.StringValue analyzer = 1;

  // Beginning characters of terms you wish to find in the top-level field.
  .google.protobuf.StringValue prefix = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue use_field = 3;

}

message IntervalsWildcard {

  // Analyzer used to analyze the `pattern`. Defaults to the top-level field's analyzer.
  .google.protobuf.StringValue analyzer = 1;

  // Wildcard pattern used to find matching terms.
  .google.protobuf.StringValue pattern = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue use_field = 3;

}

message MatchAllQuery {

  // [optional]
  // Boosts the clause by the given multiplier. Useful for weighing clauses in compound queries. Values in the [0, 1) range decrease relevance, and values greater than 1 increase relevance. Default is 1.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];
}

message MatchBoolPrefixQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  .google.protobuf.StringValue analyzer = 3;

  // [optional]
  // The number of character edits (insert, delete, substitute) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 4;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 5;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  .google.protobuf.BoolValue fuzzy_transpositions = 6;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  .google.protobuf.Int32Value max_expansions = 7;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 8;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (and) or only one term needs to match (or) for a document to be considered a match.
  // Default is or.
  Operator operator = 9;
  enum Operator {
    
    OPERATOR_INVALID = 0;
    // All terms need to match. The string `to be` is interpreted as `to AND be`
    OPERATOR_AND = 1;
    // Only one term needs to match. The string `to be` is interpreted as `to OR be`
    OPERATOR_OR = 2;
  }

  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  .google.protobuf.Int32Value prefix_length = 10;

  // [required]
  // Terms you wish to find in the provided field. The last term is used in a prefix query.
  .google.protobuf.StringValue query = 11;

}

message MatchNoneQuery {

  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  ObjectMap object = 3;;
}

message MatchPhrasePrefixQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  .google.protobuf.StringValue analyzer = 3;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  .google.protobuf.Int32Value max_expansions = 4;

  // [required]
  // The query string to use for search
  .google.protobuf.StringValue query = 5;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase.
  // For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  .google.protobuf.Int32Value slop = 6;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 7;
  enum ZeroTermsQuery {
    
    ZERO_TERMS_QUERY_INVALID = 0;
    // zero_terms_query specifies whether to match all documents (all).
    ZERO_TERMS_QUERY_ALL = 1;
    // zero_terms_query specifies whether to match no documents (none)
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message MatchPhraseQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  // [optional]
  // Query name for query tagging
  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  .google.protobuf.StringValue analyzer = 3;

  // [required]
  // The query string to use for search.
  .google.protobuf.StringValue query = 4;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  .google.protobuf.Int32Value slop = 5;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 6;
  enum ZeroTermsQuery {
    
    ZERO_TERMS_QUERY_INVALID = 0;
    // zero_terms_query specifies whether to match all documents (all).
    ZERO_TERMS_QUERY_ALL = 1;
    // zero_terms_query specifies whether to match no documents (none)
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message MultiMatchQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  .google.protobuf.FloatValue boost = 1;

  .google.protobuf.StringValue name = 2 [json_name = "_name"];

  // Analyzer used to convert the text in the query value into tokens.
  .google.protobuf.StringValue analyzer = 3;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  .google.protobuf.BoolValue auto_generate_synonyms_phrase_query = 4;

  .google.protobuf.FloatValue cutoff_frequency = 5;

  repeated string fields = 6;

  Fuzziness fuzziness = 7;

  .google.protobuf.StringValue fuzzy_rewrite = 8;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). Can be applied to the term subqueries constructed for all terms but the final term.
  MultiTermQueryRewrite fuzzy_transpositions = 9;
  enum MultiTermQueryRewrite {
    
    MULTI_TERM_QUERY_REWRITE_INVALID = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.
  .google.protobuf.BoolValue lenient = 10;

  // Maximum number of terms to which the query will expand.
  .google.protobuf.Int32Value max_expansions = 11;

  MinimumShouldMatch minimum_should_match = 12;

  Operator operator = 13;
  enum Operator {
    
    OPERATOR_INVALID = 0;
    OPERATOR_AND = 1;
    OPERATOR_OR = 2;
  }

  // Number of beginning characters left unchanged for fuzzy matching.
  .google.protobuf.Int32Value prefix_length = 14;

  // Text, number, boolean value or date you wish to find in the provided field.
  .google.protobuf.StringValue query = 15;

  // Maximum number of positions allowed between matching tokens.
  .google.protobuf.Int32Value slop = 16;

  // Determines how scores for each per-term blended query and scores across groups are combined.
  .google.protobuf.FloatValue tie_breaker = 17;

  TextQueryType type = 18;
  enum TextQueryType {
    
    TEXT_QUERY_TYPE_INVALID = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

  ZeroTermsQuery zero_terms_query = 19;
  enum ZeroTermsQuery {
    
    ZERO_TERMS_QUERY_INVALID = 0;
    ZERO_TERMS_QUERY_ALL = 1;
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message FieldValueFactorScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  .google.protobuf.StringValue field = 1;

  // Optional factor to multiply the field value with.
  .google.protobuf.FloatValue factor = 2;

  // Value used if the document doesn't have that field. The modifier and factor are still applied to it as though it were read from the document.
  .google.protobuf.DoubleValue missing = 3;

  FieldValueFactorModifier modifier = 4;

  enum FieldValueFactorModifier {
    
    FIELD_VALUE_FACTOR_MODIFIER_INVALID = 0;
    FIELD_VALUE_FACTOR_MODIFIER_LN = 1;
    FIELD_VALUE_FACTOR_MODIFIER_LN1P = 2;
    FIELD_VALUE_FACTOR_MODIFIER_LN2P = 3;
    FIELD_VALUE_FACTOR_MODIFIER_LOG = 4;
    FIELD_VALUE_FACTOR_MODIFIER_LOG1P = 5;
    FIELD_VALUE_FACTOR_MODIFIER_LOG2P = 6;
    FIELD_VALUE_FACTOR_MODIFIER_NONE = 7;
    FIELD_VALUE_FACTOR_MODIFIER_RECIPROCAL = 8;
    FIELD_VALUE_FACTOR_MODIFIER_SQRT = 9;
    FIELD_VALUE_FACTOR_MODIFIER_SQUARE = 10;
  }

}

message DutchAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_DUTCH = 1;
  }
  Type type = 1;

  repeated string stopwords = 2;
}

message FingerprintAnalyzer {
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_FINGERPRINT = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  .google.protobuf.FloatValue max_output_size = 3;

  .google.protobuf.BoolValue preserve_original = 4;

  .google.protobuf.StringValue separator = 5;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 6;

  .google.protobuf.StringValue stopwords_path = 7;
}

message IcuAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_ICU_ANALYZER = 1;
  }
  Type type = 1;

  enum IcuNormalizationType {
    
    ICU_NORMALIZATION_TYPE_INVALID = 0;
    ICU_NORMALIZATION_TYPE_NFC = 1;
    ICU_NORMALIZATION_TYPE_NFKC = 2;
    ICU_NORMALIZATION_TYPE_NFKC_CF = 3;
  }
  IcuNormalizationType method = 2;

  enum IcuNormalizationMode {
    
    ICU_NORMALIZATION_MODE_INVALID = 0;
    ICU_NORMALIZATION_MODE_COMPOSE = 1;
    ICU_NORMALIZATION_MODE_DECOMPOSE = 2;
  }

  IcuNormalizationMode mode = 3;
}

//manual generate
message KeywordAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_KEYWORD = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;
}

message KuromojiAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_KUROMOJI = 1;
  }
  Type type = 1;


  enum Mode {
    
    MODE_INVALID = 0;
    MODE_EXTENDED = 1;
    MODE_NORMAL = 2;
    MODE_SEARCH = 3;
  }

  Mode mode = 2;

  .google.protobuf.StringValue user_dictionary = 3;
}


message LanguageAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_LANGUAGE = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  enum Language {
    
    LANGUAGE_INVALID = 0;
    LANGUAGE_ARABIC = 1;
    LANGUAGE_ARMENIAN = 2;
    LANGUAGE_BASQUE = 3;
    LANGUAGE_BRAZILIAN = 4;
    LANGUAGE_BULGARIAN = 5;
    LANGUAGE_CATALAN = 6;
    LANGUAGE_CHINESE = 7;
    LANGUAGE_CJK = 8;
    LANGUAGE_CZECH = 9;
    LANGUAGE_DANISH = 10;
    LANGUAGE_DUTCH = 11;
    LANGUAGE_ENGLISH = 12;
    LANGUAGE_ESTONIAN = 13;
    LANGUAGE_FINNISH = 14;
    LANGUAGE_FRENCH = 15;
    LANGUAGE_GALICIAN = 16;
    LANGUAGE_GERMAN = 17;
    LANGUAGE_GREEK = 18;
    LANGUAGE_HINDI = 19;
    LANGUAGE_HUNGARIAN = 20;
    LANGUAGE_INDONESIAN = 21;
    LANGUAGE_IRISH = 22;
    LANGUAGE_ITALIAN = 23;
    LANGUAGE_LATVIAN = 24;
    LANGUAGE_NORWEGIAN = 25;
    LANGUAGE_PERSIAN = 26;
    LANGUAGE_PORTUGUESE = 27;
    LANGUAGE_ROMANIAN = 28;
    LANGUAGE_RUSSIAN = 29;
    LANGUAGE_SORANI = 30;
    LANGUAGE_SPANISH = 31;
    LANGUAGE_SWEDISH = 32;
    LANGUAGE_THAI = 33;
    LANGUAGE_TURKISH = 34;
  }

  Language language = 3;

  repeated string stem_exclusion = 4;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 5;

  .google.protobuf.StringValue stopwords_path = 6;

}

message NoriAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_NORI = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  enum NoriDecompoundMode {
    
    NORI_DECOMPOUND_MODE_INVALID = 0;
    NORI_DECOMPOUND_MODE_NONE = 1;
    NORI_DECOMPOUND_MODE_DISCARD = 2;
    NORI_DECOMPOUND_MODE_MIXED = 3;
  }

  NoriDecompoundMode decompound_mode = 3;

  repeated string stoptags = 4;

  .google.protobuf.StringValue user_dictionary = 5;
}

message PatternAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_PATTERN = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  .google.protobuf.StringValue flags = 3;

  .google.protobuf.BoolValue lowercase = 4;

  .google.protobuf.StringValue pattern = 5;

  repeated string stopwords = 6;

}

message SimpleAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_SIMPLE = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;
}

message SnowballAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_SNOWBALL = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  enum SnowballLanguage {
    
    SNOWBALL_LANGUAGE_INVALID = 0;
    SNOWBALL_LANGUAGE_ARMENIAN = 1;
    SNOWBALL_LANGUAGE_BASQUE = 2;
    SNOWBALL_LANGUAGE_CATALAN = 3;
    SNOWBALL_LANGUAGE_DANISH = 4;
    SNOWBALL_LANGUAGE_DUTCH = 5;
    SNOWBALL_LANGUAGE_ENGLISH = 6;
    SNOWBALL_LANGUAGE_FINNISH = 7;
    SNOWBALL_LANGUAGE_FRENCH = 8;
    SNOWBALL_LANGUAGE_GERMAN = 9;
    SNOWBALL_LANGUAGE_GERMAN2 = 10;
    SNOWBALL_LANGUAGE_HUNGARIAN = 11;
    SNOWBALL_LANGUAGE_ITALIAN = 12;
    SNOWBALL_LANGUAGE_KP = 13;
    SNOWBALL_LANGUAGE_LOVINS = 14;
    SNOWBALL_LANGUAGE_NORWEGIAN = 15;
    SNOWBALL_LANGUAGE_PORTER = 16;
    SNOWBALL_LANGUAGE_PORTUGUESE = 17;
    SNOWBALL_LANGUAGE_ROMANIAN = 18;
    SNOWBALL_LANGUAGE_RUSSIAN = 19;
    SNOWBALL_LANGUAGE_SPANISH = 20;
    SNOWBALL_LANGUAGE_SWEDISH = 21;
    SNOWBALL_LANGUAGE_TURKISH = 22;
  }

  SnowballLanguage language = 3;

  repeated string stopwords = 4;
}

message StandardAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_STANDARD = 1;
  }
  Type type = 1;

  .google.protobuf.FloatValue max_token_length = 2;
  repeated string stopwords = 3;
}

message StopAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_STOP = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

  repeated string stopwords = 3;

  .google.protobuf.StringValue stopwords_path = 4;
}

message WhitespaceAnalyzer{
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_WHITESPACE = 1;
  }
  Type type = 1;

  .google.protobuf.StringValue version = 2;

}

message CustomAnalyzer {
  enum Type {
    
    TYPE_INVALID = 0;
    TYPE_CUSTOM = 1;
  }

  Type type = 1;

  repeated string char_filter = 2;

  repeated string filter = 3;

  .google.protobuf.FloatValue position_increment_gap = 4;

  .google.protobuf.FloatValue position_offset_gap = 5;

  .google.protobuf.StringValue tokenizer = 6;
}

message Analyzer {
  oneof analyzer {
    CustomAnalyzer custom_analyzer = 1;
    FingerprintAnalyzer fingerprint_analyzer = 2;
    KeywordAnalyzer keyword_analyzer = 3;
    LanguageAnalyzer language_analyzer = 4;
    NoriAnalyzer nori_analyzer = 5;
    PatternAnalyzer pattern_analyzer = 6;
    SimpleAnalyzer simple_analyzer = 7;
    StandardAnalyzer standard_analyzer = 8;
    StopAnalyzer stop_analyzer = 9;
    WhitespaceAnalyzer whitespace_analyzer = 10;
    IcuAnalyzer icu_analyzer = 11;
    KuromojiAnalyzer kuromoji_analyzer = 12;
    SnowballAnalyzer snowball_analyzer = 13;
    DutchAnalyzer dutch_analyzer = 14;
  }
}

message OpenSearchException {
  oneof version {
    OpenSearchExceptionV1 v1 = 1;
  }
}


message OpenSearchExceptionV1 {
  .google.protobuf.StringValue type = 1;
  .google.protobuf.StringValue reason = 2;
  repeated .google.protobuf.Struct root_cause = 3;

  .google.protobuf.Struct caused_by = 4;
  .google.protobuf.StringValue stack_trace = 5;
  .google.protobuf.Struct suppressed = 6;

  .google.protobuf.Struct additional_details = 7;
}

message InlineGet {

  .google.protobuf.Struct fields = 1;

  .google.protobuf.BoolValue found = 2;

  .google.protobuf.Int64Value seq_no = 3 [json_name = "_seq_no"];

  .google.protobuf.Int64Value primary_term = 4 [json_name = "_primary_term"];

  repeated string routing = 5 [json_name = "_routing"];

  .google.protobuf.Struct source = 6 [json_name = "_source"];

}
