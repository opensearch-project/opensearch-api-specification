{
  "openapi": "3.1.0",
  "info": {
    "title": "Schemas of _common.query_dsl category",
    "description": "Schemas of _common.query_dsl category",
    "version": "1.0.0"
  },
  "paths": {},
  "components": {
    "schemas": {
      "Operator": {
        "type": "string",
        "enum": [
          "and",
          "or"
        ]
      },
      "QueryContainer": {
        "type": "object",
        "properties": {
          "bool": {
            "$ref": "#/components/schemas/BoolQuery"
          },
          "boosting": {
            "$ref": "#/components/schemas/BoostingQuery"
          },
          "common": {
            "deprecated": true,
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/CommonTermsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "combined_fields": {
            "$ref": "#/components/schemas/CombinedFieldsQuery"
          },
          "constant_score": {
            "$ref": "#/components/schemas/ConstantScoreQuery"
          },
          "dis_max": {
            "$ref": "#/components/schemas/DisMaxQuery"
          },
          "distance_feature": {
            "$ref": "#/components/schemas/DistanceFeatureQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/ExistsQuery"
          },
          "function_score": {
            "$ref": "#/components/schemas/FunctionScoreQuery"
          },
          "fuzzy": {
            "description": "Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/FuzzyQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "geo_bounding_box": {
            "$ref": "#/components/schemas/GeoBoundingBoxQuery"
          },
          "geo_distance": {
            "$ref": "#/components/schemas/GeoDistanceQuery"
          },
          "geo_polygon": {
            "$ref": "#/components/schemas/GeoPolygonQuery"
          },
          "geo_shape": {
            "$ref": "#/components/schemas/GeoShapeQuery"
          },
          "has_child": {
            "$ref": "#/components/schemas/HasChildQuery"
          },
          "has_parent": {
            "$ref": "#/components/schemas/HasParentQuery"
          },
          "ids": {
            "$ref": "#/components/schemas/IdsQuery"
          },
          "intervals": {
            "description": "Returns documents based on the order and proximity of matching terms.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/IntervalsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match": {
            "description": "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/MatchAllQuery"
          },
          "match_bool_prefix": {
            "description": "Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/MatchBoolPrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_none": {
            "$ref": "#/components/schemas/MatchNoneQuery"
          },
          "match_phrase": {
            "description": "Analyzes the text and creates a phrase query out of the analyzed text.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/MatchPhraseQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_phrase_prefix": {
            "description": "Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/MatchPhrasePrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "more_like_this": {
            "$ref": "#/components/schemas/MoreLikeThisQuery"
          },
          "multi_match": {
            "$ref": "#/components/schemas/MultiMatchQuery"
          },
          "nested": {
            "$ref": "#/components/schemas/NestedQuery"
          },
          "parent_id": {
            "$ref": "#/components/schemas/ParentIdQuery"
          },
          "percolate": {
            "$ref": "#/components/schemas/PercolateQuery"
          },
          "pinned": {
            "$ref": "#/components/schemas/PinnedQuery"
          },
          "prefix": {
            "description": "Returns documents that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "query_string": {
            "$ref": "#/components/schemas/QueryStringQuery"
          },
          "range": {
            "description": "Returns documents that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rank_feature": {
            "$ref": "#/components/schemas/RankFeatureQuery"
          },
          "regexp": {
            "description": "Returns documents that contain terms matching a regular expression.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/RegexpQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rule_query": {
            "$ref": "#/components/schemas/RuleQuery"
          },
          "script": {
            "$ref": "#/components/schemas/ScriptQuery"
          },
          "script_score": {
            "$ref": "#/components/schemas/ScriptScoreQuery"
          },
          "shape": {
            "$ref": "#/components/schemas/ShapeQuery"
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/SimpleQueryStringQuery"
          },
          "span_containing": {
            "$ref": "#/components/schemas/SpanContainingQuery"
          },
          "field_masking_span": {
            "$ref": "#/components/schemas/SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/SpanFirstQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/SpanOrQuery"
          },
          "span_term": {
            "description": "Matches spans containing a term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/SpanWithinQuery"
          },
          "term": {
            "description": "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/TermsQuery"
          },
          "terms_set": {
            "description": "Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TermsSetQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "text_expansion": {
            "description": "Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/TextExpansionQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "weighted_tokens": {
            "description": "Supports returning text_expansion query results by sending in precomputed tokens with the query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/WeightedTokensQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wildcard": {
            "description": "Returns documents that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wrapper": {
            "$ref": "#/components/schemas/WrapperQuery"
          },
          "type": {
            "$ref": "#/components/schemas/TypeQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "BoolQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "description": "The clause (query) must appear in matching documents.\nHowever, unlike `must`, the score of the query will be ignored.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/QueryContainer"
                    }
                  }
                ]
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "must": {
                "description": "The clause (query) must appear in matching documents and will contribute to the score.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/QueryContainer"
                    }
                  }
                ]
              },
              "must_not": {
                "description": "The clause (query) must not appear in the matching documents.\nBecause scoring is ignored, a score of `0` is returned for all documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/QueryContainer"
                    }
                  }
                ]
              },
              "should": {
                "description": "The clause (query) should appear in the matching document.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/QueryContainer"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "QueryBase": {
        "type": "object",
        "properties": {
          "boost": {
            "description": "Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.",
            "type": "number"
          },
          "_name": {
            "type": "string"
          }
        }
      },
      "BoostingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "negative_boost": {
                "description": "Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.",
                "type": "number"
              },
              "negative": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "positive": {
                "$ref": "#/components/schemas/QueryContainer"
              }
            },
            "required": [
              "negative_boost",
              "negative",
              "positive"
            ]
          }
        ]
      },
      "CommonTermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "cutoff_frequency": {
                "type": "number"
              },
              "high_freq_operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "low_freq_operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "query": {
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "CombinedFieldsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "description": "List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.",
                "type": "array",
                "items": {
                  "$ref": "_common.json#/components/schemas/Field"
                }
              },
              "query": {
                "description": "Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If true, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "operator": {
                "$ref": "#/components/schemas/CombinedFieldsOperator"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/CombinedFieldsZeroTerms"
              }
            },
            "required": [
              "fields",
              "query"
            ]
          }
        ]
      },
      "CombinedFieldsOperator": {
        "type": "string",
        "enum": [
          "or",
          "and"
        ]
      },
      "CombinedFieldsZeroTerms": {
        "type": "string",
        "enum": [
          "none",
          "all"
        ]
      },
      "ConstantScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/QueryContainer"
              }
            },
            "required": [
              "filter"
            ]
          }
        ]
      },
      "DisMaxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "queries": {
                "description": "One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Opensearch uses the highest relevance score.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/QueryContainer"
                }
              },
              "tie_breaker": {
                "description": "Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.",
                "type": "number"
              }
            },
            "required": [
              "queries"
            ]
          }
        ]
      },
      "DistanceFeatureQuery": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/GeoDistanceFeatureQuery"
          },
          {
            "$ref": "#/components/schemas/DateDistanceFeatureQuery"
          }
        ]
      },
      "GeoDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DistanceFeatureQueryBaseGeoLocationDistance"
          },
          {
            "type": "object"
          }
        ]
      },
      "DistanceFeatureQueryBaseGeoLocationDistance": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "_common.json#/components/schemas/GeoLocation"
              },
              "pivot": {
                "$ref": "_common.json#/components/schemas/Distance"
              },
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "DateDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DistanceFeatureQueryBaseDateMathDuration"
          },
          {
            "type": "object"
          }
        ]
      },
      "DistanceFeatureQueryBaseDateMathDuration": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "_common.json#/components/schemas/DateMath"
              },
              "pivot": {
                "$ref": "_common.json#/components/schemas/Duration"
              },
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "ExistsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "FunctionScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "boost_mode": {
                "$ref": "#/components/schemas/FunctionBoostMode"
              },
              "functions": {
                "description": "One or more functions that compute a new score for each document returned by the query.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/FunctionScoreContainer"
                }
              },
              "max_boost": {
                "description": "Restricts the new score to not exceed the provided limit.",
                "type": "number"
              },
              "min_score": {
                "description": "Excludes documents that do not meet the provided score threshold.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/FunctionScoreMode"
              }
            }
          }
        ]
      },
      "FunctionBoostMode": {
        "type": "string",
        "enum": [
          "multiply",
          "replace",
          "sum",
          "avg",
          "max",
          "min"
        ]
      },
      "FunctionScoreContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "weight": {
                "type": "number"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "exp": {
                "$ref": "#/components/schemas/DecayFunction"
              },
              "gauss": {
                "$ref": "#/components/schemas/DecayFunction"
              },
              "linear": {
                "$ref": "#/components/schemas/DecayFunction"
              },
              "field_value_factor": {
                "$ref": "#/components/schemas/FieldValueFactorScoreFunction"
              },
              "random_score": {
                "$ref": "#/components/schemas/RandomScoreFunction"
              },
              "script_score": {
                "$ref": "#/components/schemas/ScriptScoreFunction"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "DecayFunction": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DateDecayFunction"
          },
          {
            "$ref": "#/components/schemas/NumericDecayFunction"
          },
          {
            "$ref": "#/components/schemas/GeoDecayFunction"
          }
        ]
      },
      "DateDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "DecayFunctionBase": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/MultiValueMode"
          }
        }
      },
      "MultiValueMode": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "avg",
          "sum"
        ]
      },
      "NumericDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "GeoDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "FieldValueFactorScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "_common.json#/components/schemas/Field"
          },
          "factor": {
            "description": "Optional factor to multiply the field value with.",
            "type": "number"
          },
          "missing": {
            "description": "Value used if the document doesnâ€™t have that field.\nThe modifier and factor are still applied to it as though it were read from the document.",
            "type": "number"
          },
          "modifier": {
            "$ref": "#/components/schemas/FieldValueFactorModifier"
          }
        },
        "required": [
          "field"
        ]
      },
      "FieldValueFactorModifier": {
        "type": "string",
        "enum": [
          "none",
          "log",
          "log1p",
          "log2p",
          "ln",
          "ln1p",
          "ln2p",
          "square",
          "sqrt",
          "reciprocal"
        ]
      },
      "RandomScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "_common.json#/components/schemas/Field"
          },
          "seed": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "ScriptScoreFunction": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "_common.json#/components/schemas/Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "FunctionScoreMode": {
        "type": "string",
        "enum": [
          "multiply",
          "sum",
          "avg",
          "first",
          "max",
          "min"
        ]
      },
      "FuzzyQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "max_expansions": {
                "description": "Maximum number of variations created.",
                "type": "number"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged when creating expansions.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "transpositions": {
                "description": "Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).",
                "type": "boolean"
              },
              "fuzziness": {
                "$ref": "_common.json#/components/schemas/Fuzziness"
              },
              "value": {
                "description": "Term you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "GeoBoundingBoxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/GeoExecution"
              },
              "validation_method": {
                "$ref": "#/components/schemas/GeoValidationMethod"
              },
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "GeoExecution": {
        "type": "string",
        "enum": [
          "memory",
          "indexed"
        ]
      },
      "GeoValidationMethod": {
        "type": "string",
        "enum": [
          "coerce",
          "ignore_malformed",
          "strict"
        ]
      },
      "GeoDistanceQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "distance": {
                "$ref": "_common.json#/components/schemas/Distance"
              },
              "distance_type": {
                "$ref": "_common.json#/components/schemas/GeoDistanceType"
              },
              "validation_method": {
                "$ref": "#/components/schemas/GeoValidationMethod"
              }
            },
            "required": [
              "distance"
            ]
          }
        ]
      },
      "GeoPolygonQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "validation_method": {
                "$ref": "#/components/schemas/GeoValidationMethod"
              },
              "ignore_unmapped": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "GeoShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "HasChildQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "_core.search.json#/components/schemas/InnerHits"
              },
              "max_children": {
                "description": "Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.",
                "type": "number"
              },
              "min_children": {
                "description": "Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/ChildScoreMode"
              },
              "type": {
                "$ref": "_common.json#/components/schemas/RelationName"
              }
            },
            "required": [
              "query",
              "type"
            ]
          }
        ]
      },
      "FieldAndFormat": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "_common.json#/components/schemas/Field"
          },
          "format": {
            "description": "Format in which the values are returned.",
            "type": "string"
          },
          "include_unmapped": {
            "type": "boolean"
          }
        },
        "required": [
          "field"
        ]
      },
      "ChildScoreMode": {
        "type": "string",
        "enum": [
          "none",
          "avg",
          "sum",
          "max",
          "min"
        ]
      },
      "HasParentQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "_core.search.json#/components/schemas/InnerHits"
              },
              "parent_type": {
                "$ref": "_common.json#/components/schemas/RelationName"
              },
              "query": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "score": {
                "description": "Indicates whether the relevance score of a matching parent document is aggregated into its child documents.",
                "type": "boolean"
              }
            },
            "required": [
              "parent_type",
              "query"
            ]
          }
        ]
      },
      "IdsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "values": {
                "$ref": "_common.json#/components/schemas/Ids"
              }
            }
          }
        ]
      },
      "IntervalsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "all_of": {
                "$ref": "#/components/schemas/IntervalsAllOf"
              },
              "any_of": {
                "$ref": "#/components/schemas/IntervalsAnyOf"
              },
              "fuzzy": {
                "$ref": "#/components/schemas/IntervalsFuzzy"
              },
              "match": {
                "$ref": "#/components/schemas/IntervalsMatch"
              },
              "prefix": {
                "$ref": "#/components/schemas/IntervalsPrefix"
              },
              "wildcard": {
                "$ref": "#/components/schemas/IntervalsWildcard"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "IntervalsAllOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to combine. All rules must produce a match in a document for the overall source to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntervalsContainer"
            }
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, intervals produced by the rules should appear in the order in which they are specified.",
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "IntervalsContainer": {
        "type": "object",
        "properties": {
          "all_of": {
            "$ref": "#/components/schemas/IntervalsAllOf"
          },
          "any_of": {
            "$ref": "#/components/schemas/IntervalsAnyOf"
          },
          "fuzzy": {
            "$ref": "#/components/schemas/IntervalsFuzzy"
          },
          "match": {
            "$ref": "#/components/schemas/IntervalsMatch"
          },
          "prefix": {
            "$ref": "#/components/schemas/IntervalsPrefix"
          },
          "wildcard": {
            "$ref": "#/components/schemas/IntervalsWildcard"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "IntervalsAnyOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/IntervalsContainer"
            }
          },
          "filter": {
            "$ref": "#/components/schemas/IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "IntervalsFilter": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "before": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "contained_by": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "containing": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "not_contained_by": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "not_containing": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "not_overlapping": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "overlapping": {
            "$ref": "#/components/schemas/IntervalsContainer"
          },
          "script": {
            "$ref": "_common.json#/components/schemas/Script"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "IntervalsFuzzy": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to normalize the term.",
            "type": "string"
          },
          "fuzziness": {
            "$ref": "_common.json#/components/schemas/Fuzziness"
          },
          "prefix_length": {
            "description": "Number of beginning characters left unchanged when creating expansions.",
            "type": "number"
          },
          "term": {
            "description": "The term to match.",
            "type": "string"
          },
          "transpositions": {
            "description": "Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "type": "boolean"
          },
          "use_field": {
            "$ref": "_common.json#/components/schemas/Field"
          }
        },
        "required": [
          "term"
        ]
      },
      "IntervalsMatch": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze terms in the query.",
            "type": "string"
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, matching terms must appear in their specified order.",
            "type": "boolean"
          },
          "query": {
            "description": "Text you wish to find in the provided field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "_common.json#/components/schemas/Field"
          },
          "filter": {
            "$ref": "#/components/schemas/IntervalsFilter"
          }
        },
        "required": [
          "query"
        ]
      },
      "IntervalsPrefix": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze the `prefix`.",
            "type": "string"
          },
          "prefix": {
            "description": "Beginning characters of terms you wish to find in the top-level field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "_common.json#/components/schemas/Field"
          }
        },
        "required": [
          "prefix"
        ]
      },
      "IntervalsWildcard": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze the `pattern`.\nDefaults to the top-level field's analyzer.",
            "type": "string"
          },
          "pattern": {
            "description": "Wildcard pattern used to find matching terms.",
            "type": "string"
          },
          "use_field": {
            "$ref": "_common.json#/components/schemas/Field"
          }
        },
        "required": [
          "pattern"
        ]
      },
      "MatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fuzziness": {
                "$ref": "_common.json#/components/schemas/Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "ZeroTermsQuery": {
        "type": "string",
        "enum": [
          "all",
          "none"
        ]
      },
      "MatchAllQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "MatchBoolPrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "fuzziness": {
                "$ref": "_common.json#/components/schemas/Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "query": {
                "description": "Terms you wish to find in the provided field.\nThe last term is used in a prefix query.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "MatchNoneQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "MatchPhraseQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "query": {
                "description": "Query terms that are analyzed and turned into a phrase query.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "MatchPhrasePrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert text in the query value into tokens.",
                "type": "string"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the last provided term of the query value will expand.",
                "type": "number"
              },
              "query": {
                "description": "Text you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "MoreLikeThisQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.",
                "type": "string"
              },
              "boost_terms": {
                "description": "Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).",
                "type": "number"
              },
              "fail_on_unsupported_field": {
                "description": "Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).",
                "type": "boolean"
              },
              "fields": {
                "description": "A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "_common.json#/components/schemas/Field"
                }
              },
              "include": {
                "description": "Specifies whether the input documents should also be included in the search results returned.",
                "type": "boolean"
              },
              "like": {
                "description": "Specifies free form text and/or a single or multiple documents for which you want to find similar documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/Like"
                    }
                  }
                ]
              },
              "max_doc_freq": {
                "description": "The maximum document frequency above which the terms are ignored from the input document.",
                "type": "number"
              },
              "max_query_terms": {
                "description": "The maximum number of query terms that can be selected.",
                "type": "number"
              },
              "max_word_length": {
                "description": "The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).",
                "type": "number"
              },
              "min_doc_freq": {
                "description": "The minimum document frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "min_term_freq": {
                "description": "The minimum term frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "min_word_length": {
                "description": "The minimum word length below which the terms are ignored.",
                "type": "number"
              },
              "per_field_analyzer": {
                "description": "Overrides the default analyzer.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "routing": {
                "$ref": "_common.json#/components/schemas/Routing"
              },
              "stop_words": {
                "$ref": "_common.analysis.json#/components/schemas/StopWords"
              },
              "unlike": {
                "description": "Used in combination with `like` to exclude documents that match a set of terms.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/Like"
                    }
                  }
                ]
              },
              "version": {
                "$ref": "_common.json#/components/schemas/VersionNumber"
              },
              "version_type": {
                "$ref": "_common.json#/components/schemas/VersionType"
              }
            },
            "required": [
              "like"
            ]
          }
        ]
      },
      "Like": {
        "description": "Text that we want similar documents for or a lookup to a document's field for the text.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/LikeDocument"
          }
        ]
      },
      "LikeDocument": {
        "type": "object",
        "properties": {
          "doc": {
            "description": "A document not present in the index.",
            "type": "object"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "_common.json#/components/schemas/Field"
            }
          },
          "_id": {
            "$ref": "_common.json#/components/schemas/Id"
          },
          "_index": {
            "$ref": "_common.json#/components/schemas/IndexName"
          },
          "per_field_analyzer": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "routing": {
            "$ref": "_common.json#/components/schemas/Routing"
          },
          "version": {
            "$ref": "_common.json#/components/schemas/VersionNumber"
          },
          "version_type": {
            "$ref": "_common.json#/components/schemas/VersionType"
          }
        }
      },
      "MultiMatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fields": {
                "$ref": "_common.json#/components/schemas/Fields"
              },
              "fuzziness": {
                "$ref": "_common.json#/components/schemas/Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "tie_breaker": {
                "description": "Determines how scores for each per-term blended query and scores across groups are combined.",
                "type": "number"
              },
              "type": {
                "$ref": "#/components/schemas/TextQueryType"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "TextQueryType": {
        "type": "string",
        "enum": [
          "best_fields",
          "most_fields",
          "cross_fields",
          "phrase",
          "phrase_prefix",
          "bool_prefix"
        ]
      },
      "NestedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped path and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "_core.search.json#/components/schemas/InnerHits"
              },
              "path": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "query": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/ChildScoreMode"
              }
            },
            "required": [
              "path",
              "query"
            ]
          }
        ]
      },
      "ParentIdQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "_common.json#/components/schemas/Id"
              },
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "type": {
                "$ref": "_common.json#/components/schemas/RelationName"
              }
            }
          }
        ]
      },
      "PercolateQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "document": {
                "description": "The source of the document being percolated.",
                "type": "object"
              },
              "documents": {
                "description": "An array of sources of the documents being percolated.",
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "id": {
                "$ref": "_common.json#/components/schemas/Id"
              },
              "index": {
                "$ref": "_common.json#/components/schemas/IndexName"
              },
              "name": {
                "description": "The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.",
                "type": "string"
              },
              "preference": {
                "description": "Preference used to fetch document to percolate.",
                "type": "string"
              },
              "routing": {
                "$ref": "_common.json#/components/schemas/Routing"
              },
              "version": {
                "$ref": "_common.json#/components/schemas/VersionNumber"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "PinnedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "organic": {
                    "$ref": "#/components/schemas/QueryContainer"
                  }
                },
                "required": [
                  "organic"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "ids": {
                    "description": "Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "_common.json#/components/schemas/Id"
                    }
                  },
                  "docs": {
                    "description": "Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/PinnedDoc"
                    }
                  }
                },
                "minProperties": 1,
                "maxProperties": 1
              }
            ]
          }
        ]
      },
      "PinnedDoc": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "_common.json#/components/schemas/Id"
          },
          "_index": {
            "$ref": "_common.json#/components/schemas/IndexName"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "PrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "value": {
                "description": "Beginning characters of terms you wish to find in the provided field.",
                "type": "string"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "QueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "allow_leading_wildcard": {
                "description": "If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.",
                "type": "boolean"
              },
              "analyzer": {
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "default_field": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "default_operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "enable_position_increments": {
                "description": "If `true`, enable position increments in queries constructed from a `query_string` search.",
                "type": "boolean"
              },
              "escape": {
                "type": "boolean"
              },
              "fields": {
                "description": "Array of fields to search. Supports wildcards (`*`).",
                "type": "array",
                "items": {
                  "$ref": "_common.json#/components/schemas/Field"
                }
              },
              "fuzziness": {
                "$ref": "_common.json#/components/schemas/Fuzziness"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "phrase_slop": {
                "description": "Maximum number of positions allowed between matching tokens for phrases.",
                "type": "number"
              },
              "query": {
                "description": "Query string you wish to parse and use for search.",
                "type": "string"
              },
              "quote_analyzer": {
                "description": "Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.",
                "type": "string"
              },
              "rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "tie_breaker": {
                "description": "How to combine the queries generated from the individual search terms in the resulting `dis_max` query.",
                "type": "number"
              },
              "time_zone": {
                "$ref": "_common.json#/components/schemas/TimeZone"
              },
              "type": {
                "$ref": "#/components/schemas/TextQueryType"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "RangeQuery": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/DateRangeQuery"
          },
          {
            "$ref": "#/components/schemas/NumberRangeQuery"
          }
        ]
      },
      "DateRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RangeQueryBase"
          },
          {
            "type": "object",
            "properties": {
              "gt": {
                "$ref": "_common.json#/components/schemas/DateMath"
              },
              "gte": {
                "$ref": "_common.json#/components/schemas/DateMath"
              },
              "lt": {
                "$ref": "_common.json#/components/schemas/DateMath"
              },
              "lte": {
                "$ref": "_common.json#/components/schemas/DateMath"
              },
              "from": {
                "oneOf": [
                  {
                    "$ref": "_common.json#/components/schemas/DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "oneOf": [
                  {
                    "$ref": "_common.json#/components/schemas/DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "format": {
                "$ref": "_common.json#/components/schemas/DateFormat"
              },
              "time_zone": {
                "$ref": "_common.json#/components/schemas/TimeZone"
              }
            }
          }
        ]
      },
      "RangeQueryBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/RangeRelation"
              }
            }
          }
        ]
      },
      "RangeRelation": {
        "type": "string",
        "enum": [
          "within",
          "contains",
          "intersects"
        ]
      },
      "NumberRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RangeQueryBase"
          },
          {
            "type": "object",
            "properties": {
              "gt": {
                "description": "Greater than.",
                "type": "number"
              },
              "gte": {
                "description": "Greater than or equal to.",
                "type": "number"
              },
              "lt": {
                "description": "Less than.",
                "type": "number"
              },
              "lte": {
                "description": "Less than or equal to.",
                "type": "number"
              },
              "from": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "RankFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "saturation": {
                "$ref": "#/components/schemas/RankFeatureFunctionSaturation"
              },
              "log": {
                "$ref": "#/components/schemas/RankFeatureFunctionLogarithm"
              },
              "linear": {
                "$ref": "#/components/schemas/RankFeatureFunctionLinear"
              },
              "sigmoid": {
                "$ref": "#/components/schemas/RankFeatureFunctionSigmoid"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "RankFeatureFunctionSaturation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              }
            }
          }
        ]
      },
      "RankFeatureFunction": {
        "type": "object"
      },
      "RankFeatureFunctionLogarithm": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "scaling_factor": {
                "description": "Configurable scaling factor.",
                "type": "number"
              }
            },
            "required": [
              "scaling_factor"
            ]
          }
        ]
      },
      "RankFeatureFunctionLinear": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RankFeatureFunction"
          },
          {
            "type": "object"
          }
        ]
      },
      "RankFeatureFunctionSigmoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              },
              "exponent": {
                "description": "Configurable Exponent.",
                "type": "number"
              }
            },
            "required": [
              "pivot",
              "exponent"
            ]
          }
        ]
      },
      "RegexpQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              },
              "flags": {
                "description": "Enables optional operators for the regular expression.",
                "type": "string"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "value": {
                "description": "Regular expression for terms you wish to find in the provided field.",
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "RuleQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "organic": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "ruleset_id": {
                "$ref": "_common.json#/components/schemas/Id"
              },
              "match_criteria": {
                "type": "object"
              }
            },
            "required": [
              "organic",
              "ruleset_id",
              "match_criteria"
            ]
          }
        ]
      },
      "ScriptQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "_common.json#/components/schemas/Script"
              }
            },
            "required": [
              "script"
            ]
          }
        ]
      },
      "ScriptScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "min_score": {
                "description": "Documents with a score lower than this floating point number are excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/QueryContainer"
              },
              "script": {
                "$ref": "_common.json#/components/schemas/Script"
              }
            },
            "required": [
              "query",
              "script"
            ]
          }
        ]
      },
      "ShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "When set to `true` the query ignores an unmapped field and will not match any documents.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "SimpleQueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, the parser creates a match_phrase query for each multi-position token.",
                "type": "boolean"
              },
              "default_operator": {
                "$ref": "#/components/schemas/Operator"
              },
              "fields": {
                "description": "Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "_common.json#/components/schemas/Field"
                }
              },
              "flags": {
                "$ref": "#/components/schemas/SimpleQueryStringFlags"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "minimum_should_match": {
                "$ref": "_common.json#/components/schemas/MinimumShouldMatch"
              },
              "query": {
                "description": "Query string in the simple query string syntax you wish to parse and use for search.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "SimpleQueryStringFlags": {
        "description": "Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`",
        "allOf": [
          {
            "$ref": "_common.json#/components/schemas/PipeSeparatedFlagsSimpleQueryStringFlag"
          }
        ]
      },
      "SimpleQueryStringFlag": {
        "type": "string",
        "enum": [
          "NONE",
          "AND",
          "NOT",
          "OR",
          "PREFIX",
          "PHRASE",
          "PRECEDENCE",
          "ESCAPE",
          "WHITESPACE",
          "FUZZY",
          "NEAR",
          "SLOP",
          "ALL"
        ]
      },
      "SpanContainingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "SpanQuery": {
        "type": "object",
        "properties": {
          "span_containing": {
            "$ref": "#/components/schemas/SpanContainingQuery"
          },
          "field_masking_span": {
            "$ref": "#/components/schemas/SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/SpanFirstQuery"
          },
          "span_gap": {
            "$ref": "#/components/schemas/SpanGapQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/SpanOrQuery"
          },
          "span_term": {
            "description": "The equivalent of the `term` query but for use with other span queries.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/SpanWithinQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "SpanFieldMaskingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "query": {
                "$ref": "#/components/schemas/SpanQuery"
              }
            },
            "required": [
              "field",
              "query"
            ]
          }
        ]
      },
      "SpanFirstQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "end": {
                "description": "Controls the maximum end position permitted in a match.",
                "type": "number"
              },
              "match": {
                "$ref": "#/components/schemas/SpanQuery"
              }
            },
            "required": [
              "end",
              "match"
            ]
          }
        ]
      },
      "SpanGapQuery": {
        "description": "Can only be used as a clause in a span_near query.",
        "type": "object",
        "additionalProperties": {
          "type": "number"
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "SpanMultiTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "match": {
                "$ref": "#/components/schemas/QueryContainer"
              }
            },
            "required": [
              "match"
            ]
          }
        ]
      },
      "SpanNearQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SpanQuery"
                }
              },
              "in_order": {
                "description": "Controls whether matches are required to be in-order.",
                "type": "boolean"
              },
              "slop": {
                "description": "Controls the maximum number of intervening unmatched positions permitted.",
                "type": "number"
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "SpanNotQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "dist": {
                "description": "The number of tokens from within the include span that canâ€™t have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.",
                "type": "number"
              },
              "exclude": {
                "$ref": "#/components/schemas/SpanQuery"
              },
              "include": {
                "$ref": "#/components/schemas/SpanQuery"
              },
              "post": {
                "description": "The number of tokens after the include span that canâ€™t have overlap with the exclude span.",
                "type": "number"
              },
              "pre": {
                "description": "The number of tokens before the include span that canâ€™t have overlap with the exclude span.",
                "type": "number"
              }
            },
            "required": [
              "exclude",
              "include"
            ]
          }
        ]
      },
      "SpanOrQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SpanQuery"
                }
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "SpanTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "SpanWithinQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "TermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "_common.json#/components/schemas/FieldValue"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "TermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "TermsSetQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "minimum_should_match_field": {
                "$ref": "_common.json#/components/schemas/Field"
              },
              "minimum_should_match_script": {
                "$ref": "_common.json#/components/schemas/Script"
              },
              "terms": {
                "description": "Array of terms you wish to find in the provided field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "terms"
            ]
          }
        ]
      },
      "TextExpansionQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "description": "The text expansion NLP model to use",
                "type": "string"
              },
              "model_text": {
                "description": "The query text",
                "type": "string"
              },
              "pruning_config": {
                "$ref": "#/components/schemas/TokenPruningConfig"
              }
            },
            "required": [
              "model_id",
              "model_text"
            ]
          }
        ]
      },
      "TokenPruningConfig": {
        "type": "object",
        "properties": {
          "tokens_freq_ratio_threshold": {
            "description": "Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned.",
            "type": "number"
          },
          "tokens_weight_threshold": {
            "description": "Tokens whose weight is less than this threshold are considered nonsignificant and pruned.",
            "type": "number"
          },
          "only_score_pruned_tokens": {
            "description": "Whether to only score pruned tokens, vs only scoring kept tokens.",
            "type": "boolean"
          }
        }
      },
      "WeightedTokensQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "tokens": {
                "description": "The tokens representing this query",
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              },
              "pruning_config": {
                "$ref": "#/components/schemas/TokenPruningConfig"
              }
            },
            "required": [
              "tokens"
            ]
          }
        ]
      },
      "WildcardQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              },
              "rewrite": {
                "$ref": "_common.json#/components/schemas/MultiTermQueryRewrite"
              },
              "value": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.",
                "type": "string"
              },
              "wildcard": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.",
                "type": "string"
              }
            }
          }
        ]
      },
      "WrapperQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "query": {
                "description": "A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "TypeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      }
    }
  }
}